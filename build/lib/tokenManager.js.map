{
  "version": 3,
  "sources": ["../../src/lib/tokenManager.ts"],
  "sourcesContent": ["interface TokenResponse {\n\tsuccess: {\n\t\ttoken: string;\n\t\trefresh_token: string;\n\t\texpires_in: number;\n\t\tsuper_user: number;\n\t\tuserID: number;\n\t\trouteIcon: string;\n\t\treset: number;\n\t\tappMode: string;\n\t};\n}\n\ninterface TokenData {\n\taccessToken: string;\n\trefreshToken: string;\n\tuserId: number;\n\texpiresAt: number;\n}\n\n/**\n * @file tokenManager.ts\n * @description This file contains the TokenManager class which handles token management for the Paj GPS service.\n * It includes methods to get access tokens, refresh tokens, and store token data.\n */\nexport class TokenManager {\n\tprivate tokenData: TokenData | null = null;\n\tprivate refreshingTokenPromise: Promise<string> | null = null;\n\tprivate tokenPromise: Promise<TokenData> | null = null;\n\tprivate refreshLock: Promise<void> | null = null;\n\tprivate releaseRefreshLock: (() => void) | null = null;\n\tprivate baseUrl: string = 'https://connect.paj-gps.de/api/v1/';\n\n\t/**\n\t * @description Initializes the TokenManager with the adapter, email, and password.\n\t * @param adapter The ioBroker adapter instance.\n\t * @param email The email address for authentication.\n\t * @param password The password for authentication.\n\t */\n\tconstructor(\n\t\tprivate readonly adapter: ioBroker.Adapter,\n\t\tprivate readonly email: string,\n\t\tprivate readonly password: string,\n\t) {\n\t\tif (!email || !password) {\n\t\t\tthrow new Error('Email and password must be provided');\n\t\t}\n\t\tthis.email = email;\n\t\tthis.password = password;\n\t\t//this.tokenPromise = this.initTokenData();\n\t}\n\n\t/**\n\t *\n\t * @returns The access token if available and valid, otherwise refreshes the token.\n\t * @throws {Error} If the token cannot be retrieved or refreshed.\n\t */\n\tasync getAccessToken(): Promise<string> {\n\t\tthis.adapter.log.debug('[getAccessToken#]');\n\n\t\t// Token aus Storage holen\n\t\tthis.tokenData = await this.getStoredTokenData();\n\t\tthis.adapter.log.debug(\n\t\t\t`[getAccessToken] Loaded token (expires at: ${this.tokenData ? this.showTimeStamp(this.tokenData.expiresAt) : 'N/A'})`,\n\t\t);\n\n\t\t// Token noch g\u00FCltig?\n\t\tif (this.tokenData && Date.now() < this.tokenData.expiresAt - 60000) {\n\t\t\tthis.adapter.log.debug('[getAccessToken] Token valid, returning.');\n\t\t\treturn this.tokenData.accessToken;\n\t\t}\n\n\t\t// Wenn Sperre aktiv: warten\n\t\tif (this.refreshLock) {\n\t\t\tthis.adapter.log.debug('[getAccessToken] Refresh in progress, waiting...');\n\t\t\tawait this.refreshLock;\n\n\t\t\t// Nach Warten: g\u00FCltiger Token?\n\t\t\tif (this.tokenData && Date.now() < this.tokenData.expiresAt - 60000) {\n\t\t\t\tthis.adapter.log.debug('[getAccessToken] Got refreshed token after wait.');\n\t\t\t\treturn this.tokenData.accessToken;\n\t\t\t}\n\t\t\tthis.adapter.log.error('[getAccessToken] No valid token even after waiting!');\n\t\t\tthrow new Error('Token refresh failed or timed out');\n\t\t}\n\n\t\t// Jetzt exklusiv Sperre setzen\n\t\tthis.adapter.log.debug('[getAccessToken] Starting exclusive token refresh...');\n\t\tthis.refreshLock = new Promise<void>(resolve => {\n\t\t\tthis.releaseRefreshLock = resolve;\n\t\t});\n\n\t\ttry {\n\t\t\t// Versuche Refresh mit Refresh-Token\n\t\t\ttry {\n\t\t\t\tthis.adapter.log.info('[getAccessToken] Refreshing token via refresh_token...');\n\t\t\t\tthis.tokenData = await this.getTokenWithRefreshtoken();\n\t\t\t} catch (error: unknown) {\n\t\t\t\tthis.adapter.log.warn(\n\t\t\t\t\t`[getAccessToken] Refresh failed, doing full login...${error instanceof Error ? error.message : ''}`,\n\t\t\t\t);\n\t\t\t\tthis.tokenData = await this.getTokenWithLogin();\n\t\t\t}\n\n\t\t\tif (!this.tokenData) {\n\t\t\t\tthrow new Error('Token refresh/login returned no data.');\n\t\t\t}\n\n\t\t\tawait this.storeToken();\n\t\t\tthis.adapter.log.info('[getAccessToken] Token obtained successfully.');\n\t\t\treturn this.tokenData.accessToken;\n\t\t} finally {\n\t\t\t// Sperre aufheben\n\t\t\tconst release = this.releaseRefreshLock;\n\t\t\tthis.refreshLock = null;\n\t\t\tthis.releaseRefreshLock = null;\n\t\t\tif (release) {\n\t\t\t\trelease();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Login to the API and retrieves the access token.\n\t *\n\t * @returns The token data containing access token, refresh token, and expiration time.\n\t * @throws {Error} If the login fails or the response is invalid.\n\t */\n\tprivate async getTokenWithLogin(): Promise<TokenData> {\n\t\tthis.adapter.log.debug('[getTokenWithLogin#]');\n\t\tconst spezUrl = 'login?email=';\n\t\tconst urlBinder = '&password=';\n\t\tconst url = [\n\t\t\tthis.baseUrl,\n\t\t\tspezUrl,\n\t\t\tencodeURIComponent(this.email),\n\t\t\turlBinder,\n\t\t\tencodeURIComponent(this.password),\n\t\t].join('');\n\n\t\tconst res = await fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t});\n\n\t\tthis.adapter.log.info(`[getTokenWithLogin] Response: ${res.status} ${res.statusText}`);\n\t\tif (!res.ok) {\n\t\t\tthrow new Error(`Login failed: ${res.statusText}`);\n\t\t}\n\n\t\tconst data = (await res.json()) as TokenResponse;\n\t\t//console.log('RAW Login ' + JSON.stringify(data));\n\n\t\tif (\n\t\t\t!data.success ||\n\t\t\t!data.success.token ||\n\t\t\t!data.success.refresh_token ||\n\t\t\t!data.success.expires_in ||\n\t\t\t!data.success.userID\n\t\t) {\n\t\t\tthrow new Error('Login response is missing required fields');\n\t\t}\n\n\t\tconst tokenData: TokenData = {\n\t\t\taccessToken: data.success.token,\n\t\t\trefreshToken: data.success.refresh_token,\n\t\t\tuserId: data.success.userID,\n\t\t\t//expiresAt: Date.now() + data.success.expires_in * 1000,\n\t\t\t//expiresAt: Date.now() + 900000, // 15 Minuten Puffer\n\t\t\texpiresAt: Date.now() + 86400000, // 24 Stunden\n\t\t};\n\n\t\treturn tokenData;\n\t}\n\n\t/**\n\t *\n\t * @returns The token data containing access token, refresh token, and expiration time.\n\t * @throws {Error} If the token cannot be refreshed.\n\t */\n\tprivate async getTokenWithRefreshtoken(): Promise<TokenData> {\n\t\t//private async refreshAccessToken(refreshToken: string): Promise<TokenData> {\n\t\tthis.adapter.log.debug('[getTokenWithRefreshtoken#]');\n\t\tconst spezUrl = 'updatetoken?email=';\n\t\tconst urlBinder = '&refresh_token=';\n\n\t\t// Check if refreshToken is available\n\n\t\tif (!this.tokenData || !this.tokenData.refreshToken) {\n\t\t\t//if (!refreshToken) {\n\t\t\tthrow new Error('No refresh token available for refreshing access token');\n\t\t}\n\n\t\tconst url = [\n\t\t\tthis.baseUrl,\n\t\t\tspezUrl,\n\t\t\tencodeURIComponent(this.email),\n\t\t\turlBinder,\n\t\t\tthis.tokenData?.refreshToken,\n\t\t].join('');\n\t\t//const url = [this.baseUrl, spezUrl, encodeURIComponent(this.email), urlBinder, refreshToken].join('');\n\n\t\tconst res = await fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t});\n\n\t\tthis.adapter.log.info(`[getTokenWithRefreshtoken] Response: ${res.status} ${res.statusText}`);\n\n\t\tif (!res.ok) {\n\t\t\tthrow new Error(`Token refresh failed: ${res.statusText}`);\n\t\t}\n\t\tconst data = (await res.json()) as TokenResponse;\n\t\t//console.log('RAW ' + data);\n\t\tif (\n\t\t\t!data.success ||\n\t\t\t!data.success.token ||\n\t\t\t!data.success.refresh_token ||\n\t\t\t!data.success.expires_in ||\n\t\t\t!data.success.userID\n\t\t) {\n\t\t\tthrow new Error('Login response is missing required fields');\n\t\t}\n\n\t\tconst tokenData: TokenData = {\n\t\t\taccessToken: data.success.token,\n\t\t\trefreshToken: data.success.refresh_token,\n\t\t\tuserId: data.success.userID,\n\t\t\t//expiresAt: Date.now() + data.success.expires_in * 1000,\n\t\t\t//expiresAt: Date.now() + 900000, // 15 Minuten Puffer\n\t\t\texpiresAt: Date.now() + 86400000, // 24 Stunden\n\t\t};\n\t\treturn tokenData;\n\t}\n\n\t/**\n\t *\n\t * @description Initializes the token data by retrieving it from storage or logging in.\n\t * If no token data is found, it attempts to log in and store the new token data.\n\t * If the login fails, it throws an error.\n\t */\n\tprivate async storeToken(): Promise<void> {\n\t\tthis.adapter.log.debug('[storeToken#]');\n\t\t// Check if tokenData is available\n\t\tif (!this.tokenData || !this.tokenData.accessToken) {\n\t\t\tthis.adapter.log.warn('[storeToken] No access token available to store');\n\t\t\treturn;\n\t\t}\n\t\t// Store the token in the adapter's native object\n\t\tawait this.adapter.extendForeignObject(`system.adapter.${this.adapter.namespace}`, {\n\t\t\tnative: {\n\t\t\t\tactiveToken: this.tokenData,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Initializes the token data.\n\t *\n\t * @returns The token data containing access token, refresh token, user ID, and expiration time.\n\t * @description Initializes the token data by retrieving it from storage or logging in.\n\t * If no token data is found, it attempts to log in and store the new token data.\n\t * If the login fails, it throws an error.\n\t * @throws {Error} If the login fails or the token data cannot be retrieved.\n\t */\n\tasync initTokenData(): Promise<TokenData> {\n\t\t// Retrieve token Data\n\t\t//return (async () => {\n\n\t\tthis.adapter.log.debug('[initTokenData#]');\n\t\tlet tokenData = await this.getStoredTokenData();\n\n\t\tif (!tokenData) {\n\t\t\ttry {\n\t\t\t\ttokenData = await this.getTokenWithLogin();\n\t\t\t\tawait this.storeToken();\n\t\t\t\t//await this.storeToken(tokenData);\n\t\t\t} catch (error) {\n\t\t\t\tthis.adapter.log.error(\n\t\t\t\t\t`[initTokenData] Login failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n\t\t\t\t);\n\t\t\t\tthrow new Error(`Login failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.adapter.log.debug(`initTokenData: Tokendata: ${tokenData.expiresAt}`);\n\t\tthis.tokenData = tokenData;\n\t\tthis.tokenPromise = null;\n\t\treturn tokenData;\n\t\t//})();\n\t}\n\n\t/**\n\t * Initializes the token data.\n\t *\n\t * @returns The stored token data if available, otherwise null.\n\t * @description Retrieves the stored token data from the adapter's native object.\n\t * If the token data is found, it logs the expiration time.\n\t * If no token data is found, it logs a debug message and returns null.\n\t * @throws {Error} If the token data cannot be retrieved.\n\t */\n\tasync getStoredTokenData(): Promise<TokenData | null> {\n\t\tthis.adapter.log.debug('[getStoredTokenData#]');\n\t\t// Return the stored token data if available\n\t\treturn await this.adapter.getForeignObjectAsync(`system.adapter.${this.adapter.namespace}`).then(obj => {\n\t\t\tif (obj && obj.native && obj.native.activeToken) {\n\t\t\t\t//this.adapter.log.debug(`[getStoredTokenData] Loaded token data: ${JSON.stringify(obj.native.activeToken)}`);\n\t\t\t\treturn {\n\t\t\t\t\taccessToken: obj.native.activeToken.accessToken,\n\t\t\t\t\trefreshToken: obj.native.activeToken.refreshToken,\n\t\t\t\t\tuserId: obj.native.activeToken.userId,\n\t\t\t\t\texpiresAt: obj.native.activeToken.expiresAt,\n\t\t\t\t};\n\t\t\t}\n\t\t\tthis.adapter.log.debug('[getStoredTokenData] No token data found');\n\t\t\treturn null;\n\t\t});\n\t}\n\n\t/**\n\t * Formats a timestamp into a human-readable string.\n\t *\n\t * @param ts The timestamp to format.\n\t * @returns The formatted timestamp string.\n\t * @description Formats the given timestamp into a localized time string.\n\t */\n\tprivate showTimeStamp(ts: number): string {\n\t\tconst date = new Date(ts);\n\t\t//const dateString = date.toISOString();\n\t\tconst dateString = date.toLocaleTimeString(); //  .toLocaleDateString();\n\t\t//console.log(dateString);\n\t\treturn dateString;\n\t}\n\n\t/**\n\t * Retrieves the user ID (=customerId) from the token data.\n\t *\n\t * @returns The user ID if available, otherwise undefined.\n\t * @throws {Error} If the token data is not available.\n\t */\n\tgetCustomerId(): Promise<string | undefined> {\n\t\tthis.adapter.log.debug('[getCustomerId#]');\n\t\tconst customerId: string | undefined = this.tokenData ? String(this.tokenData.userId) : undefined;\n\t\tif (customerId === undefined) {\n\t\t\tthis.adapter.log.warn('[getCustomerId] No customer ID available in token data');\n\t\t\tthrow new Error('Customer ID is not available in token data');\n\t\t}\n\t\tthis.adapter.log.debug(`[getCustomerId] Customer ID: ${customerId}`);\n\t\t// Return the customer ID from the token data\n\t\treturn Promise.resolve(customerId);\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
