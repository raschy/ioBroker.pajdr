{
  "version": 3,
  "sources": ["../../src/lib/tokenManager.ts"],
  "sourcesContent": ["interface TokenResponse {\n\tsuccess: {\n\t\ttoken: string;\n\t\trefresh_token: string;\n\t\texpires_in: number;\n\t\tsuper_user: number;\n\t\tuserID: number;\n\t\trouteIcon: string;\n\t\treset: number;\n\t\tappMode: string;\n\t};\n}\n\ninterface TokenData {\n\taccessToken: string;\n\trefreshToken: string;\n\tuserId: number;\n\texpiresAt: number;\n}\n\nexport class TokenManager {\n\tprivate tokenData: TokenData | null = null;\n\tprivate refreshingTokenPromise: Promise<string> | null = null;\n\tprivate tokenPromise: Promise<TokenData> | null = null;\n\tprivate baseUrl: string = 'https://connect.paj-gps.de/api/v1/';\n\n\n\tconstructor(\n\t\tprivate readonly adapter: ioBroker.Adapter,\n\t\tprivate readonly email: string,\n\t\tprivate readonly password: string,\n\t) {\n\t\tif (!email || !password) {\n\t\t\tthrow new Error('Email and password must be provided');\n\t\t}\n\t\tthis.email = email;\n\t\tthis.password = password;\n\t\t//this.tokenPromise = this.initTokenData();\n\t}\n\n\t//\n\tasync getAccessToken_OS(): Promise<string> {\n\t\tthis.adapter.log.debug('[getAccessToken#]');\n\n\n\t\tif (!this.tokenData && this.tokenPromise) {\n\t\t\tthis.tokenData = await this.tokenPromise;\n\t\t}\n\n\t\t// Check if the token is not expired (more than a minute left)\n\t\tif (this.tokenData && Date.now() < this.tokenData.expiresAt - 60000) {\n\n\t\t\t// If the token is still valid, return it\n\t\t\tthis.adapter.log.debug(`[getAccessToken] Expires At: ${this.tokenData.expiresAt}`);\n\t\t\treturn this.tokenData.accessToken;\n\t\t}\n\n\t\t// Return result of pending refresh if one exists\n\t\tif (this.tokenPromise) {\n\t\t\tthis.adapter.log.debug('[getAccessToken] Pending refresh...');\n\t\t\tconst token = (await this.tokenPromise).accessToken;\n\t\t\tthis.adapter.log.debug(`[getAccessToken] Token: ${token}`);\n\t\t\treturn (await this.tokenPromise).accessToken\n\t\t}\n\n\t\t// Refresh tokenData\n\t\tthis.tokenPromise = (async () => {\n\t\t\ttry {\n\t\t\t\tthis.adapter.log.debug('[getAccessToken] using refresh token to retrieve new token data');\n\t\t\t\tif (!this.tokenData) {\n\t\t\t\t\tthrow new Error('Token data is not available for refresh');\n\t\t\t\t}\n\t\t\t\tthis.tokenData = await this.getTokenWithRefreshtoken();\n\t\t\t\t//this.tokenData = await this.refreshAccessToken(this.tokenData.refreshToken);\n\t\t\t\treturn this.tokenData;\n\t\t\t} catch {\n\t\t\t\tthis.adapter.log.debug('[getAccessToken] refresh with token failed, using login');\n\t\t\t\tthis.tokenData = await this.getTokenWithLogin();\n\t\t\t\treturn this.tokenData;\n\t\t\t} finally {\n\t\t\t\tthis.tokenPromise = null;\n\t\t\t}\n\t\t})();\n\n\t\tthis.storeToken();\n\n\t\t//this.storeToken(await this.tokenPromise);\n\t\treturn (await this.tokenPromise).accessToken\n\t}\n\t//\n\tasync getAccessToken_(): Promise<string> {\n\t\tthis.adapter.log.debug('[getAccessToken#]');\n\t\t//\n\t\tthis.tokenData = await this.getStoredTokenData();\n\t\tthis.adapter.log.debug(`[getAccessToken] Loaded token data expires at: ${this.tokenData ? this.showTimeStamp(this.tokenData.expiresAt) : 'N/A'}`);\n\t\t//this.adapter.log.debug(`[getAccessToken] Loaded refresh token ${this.tokenData?.accessToken.substring(0, 30)}`);\n\t\t//\n\t\t//\n\t\ttry {\n\t\t\tthis.adapter.log.info('Refreshing access token using stored refresh token...');\n\t\t\tthis.tokenData = await this.getTokenWithRefreshtoken();\n\t\t\tthis.adapter.log.debug('[getAccessToken] Token via refresh');\n\t\t\t// Check if the token is not expired (more than a minute left)\n\t\t\tif (this.tokenData && Date.now() < this.tokenData.expiresAt - 60000) {\n\t\t\t\tconst lease = this.tokenData.expiresAt - 60000 - Date.now();\n\t\t\t\tthis.adapter.log.debug(`[getAccessToken] Expires lease: ${lease}`);\n\t\t\t\treturn this.tokenData.accessToken;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis.adapter.log.warn('Stored refresh token invalid, performing full login...');\n\t\t\tthis.tokenData = await this.getTokenWithLogin();\n\t\t\tthis.adapter.log.debug('[getAccessToken] Token via LOGIN');\n\t\t}\n\t\tthis.storeToken();\n\t\treturn this.tokenData.accessToken;\n\t}\n\n\tasync getAccessToken(): Promise<string> {\n\t\tthis.adapter.log.debug('[getAccessToken#]');\n\n\t\tthis.tokenData = await this.getStoredTokenData();\n\t\tthis.adapter.log.debug(`[getAccessToken] Loaded token data expires at: ${this.tokenData ? this.showTimeStamp(this.tokenData.expiresAt) : 'N/A'}`);\n\n\t\t// Pr\u00FCfen, ob Token g\u00FCltig\n\t\tif (this.tokenData && Date.now() < this.tokenData.expiresAt - 60000) {\n\t\t\tthis.adapter.log.debug('[getAccessToken] Token still valid.');\n\t\t\treturn this.tokenData.accessToken;\n\t\t}\n\n\t\t// Wenn gerade ein anderer Vorgang den Token aktualisiert: darauf warten\n\t\tif (this.refreshingTokenPromise) {\n\t\t\tthis.adapter.log.debug('[getAccessToken] Awaiting ongoing token refresh...');\n\t\t\treturn this.refreshingTokenPromise;\n\t\t}\n\n\t\t// Jetzt exklusiv aktualisieren\n\t\tthis.refreshingTokenPromise = this.refreshTokenInternal();\n\n\t\ttry {\n\t\t\tconst token = await this.refreshingTokenPromise;\n\t\t\treturn token;\n\t\t} finally {\n\t\t\tthis.refreshingTokenPromise = null; // Nach Refresh wieder freigeben\n\t\t}\n\t}\n\n\tprivate async refreshTokenInternal(): Promise<string> {\n\t\tthis.adapter.log.debug('[refreshTokenInternal#]');\n\n\t\ttry {\n\t\t\tthis.adapter.log.info('Refreshing access token using stored refresh token...');\n\t\t\tthis.tokenData = await this.getTokenWithRefreshtoken();\n\n\t\t\tif (this.tokenData && Date.now() < this.tokenData.expiresAt - 60000) {\n\t\t\t\tthis.storeToken();\n\t\t\t\treturn this.tokenData.accessToken;\n\t\t\t}\n\n\t\t\tthrow new Error('Refreshed token is still expired');\n\t\t} catch (e) {\n\t\t\tthis.adapter.log.warn('[refreshTokenInternal] Refresh token failed, falling back to full login...');\n\t\t\tthis.tokenData = await this.getTokenWithLogin();\n\t\t\tthis.storeToken();\n\t\t\treturn this.tokenData.accessToken;\n\t\t}\n\t}\n\n\t/**\n\t * Login to the API and retrieves the access token.\n\t * @returns {Promise<TokenData>} The token data containing access token, refresh token, and expiration time.\n\t * @throws {Error} If the login fails or the response is invalid.\n\t */\n\tprivate async getTokenWithLogin(): Promise<TokenData> {\n\t\tthis.adapter.log.debug('[getTokenWithLogin#]');\n\t\tconst spezUrl: string = 'login?email=';\n\t\tconst urlBinder: string = '&password=';\n\t\tconst url = [this.baseUrl, spezUrl, encodeURIComponent(this.email), urlBinder, encodeURIComponent(this.password)].join('');\n\n\t\tconst res = await fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t});\n\n\t\tthis.adapter.log.info(`[getTokenWithLogin] Response: ${res.status} ${res.statusText}`);\n\t\tif (!res.ok) {\n\t\t\tthrow new Error(`Login failed: ${res.statusText}`);\n\t\t}\n\n\t\tconst data = await res.json() as TokenResponse;\n\n\t\tif (!data.success || !data.success.token || !data.success.refresh_token || !data.success.expires_in || !data.success.userID) {\n\t\t\tthrow new Error('Login response is missing required fields');\n\t\t}\n\n\t\tconst tokenData: TokenData = {\n\t\t\taccessToken: data.success.token,\n\t\t\trefreshToken: data.success.refresh_token,\n\t\t\tuserId: data.success.userID,\n\t\t\t//expiresAt: Date.now() + data.success.expires_in * 1000,\n\t\t\t//expiresAt: Date.now() + 900000, // 15 Minuten Puffer\n\t\t\texpiresAt: Date.now() + 300000, // 5 Minuten\n\t\t}\n\n\t\treturn tokenData;\n\t}\n\n\tprivate async getTokenWithRefreshtoken(): Promise<TokenData> {\n\t\t//private async refreshAccessToken(refreshToken: string): Promise<TokenData> {\n\t\tthis.adapter.log.debug('[getTokenWithRefreshtoken#]');\n\t\tconst spezUrl: string = 'updatetoken?email=';\n\t\tconst urlBinder: string = '&refresh_token=';\n\n\t\t// Check if refreshToken is available\n\n\t\tif (!this.tokenData || !this.tokenData.refreshToken) {\n\t\t\t//if (!refreshToken) {\n\t\t\tthrow new Error('No refresh token available for refreshing access token');\n\t\t}\n\n\t\tconst url = [this.baseUrl, spezUrl, encodeURIComponent(this.email), urlBinder, this.tokenData?.refreshToken].join('');\n\t\t//const url = [this.baseUrl, spezUrl, encodeURIComponent(this.email), urlBinder, refreshToken].join('');\n\n\t\tconst res = await fetch(url, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: { 'Content-Type': 'application/json' },\n\t\t});\n\n\t\tthis.adapter.log.info(`[getTokenWithRefreshtoken] Response: ${res.status} ${res.statusText}`);\n\n\t\tif (!res.ok) {\n\t\t\tthrow new Error(`Token refresh failed: ${res.statusText}`);\n\t\t}\n\n\t\tconst data = await res.json() as TokenResponse;\n\t\tif (!data.success || !data.success.token || !data.success.refresh_token || !data.success.expires_in || !data.success.userID) {\n\t\t\tthrow new Error('Login response is missing required fields');\n\t\t}\n\n\t\tconst tokenData: TokenData = {\n\t\t\taccessToken: data.success.token,\n\t\t\trefreshToken: data.success.refresh_token,\n\t\t\tuserId: data.success.userID,\n\t\t\t//expiresAt: Date.now() + data.success.expires_in * 1000,\n\t\t\t//expiresAt: Date.now() + 900000, // 15 Minuten Puffer\n\t\t\texpiresAt: Date.now() + 300000, // 5 Minuten Puffer\n\t\t}\n\t\treturn tokenData;\n\t}\n\n\tprivate storeToken(): void {\n\t\t//private async storeToken(tokenData: TokenData): Promise<void> {\n\t\tthis.adapter.log.debug('[storeToken#]');\n\t\t// Check if tokenData is available\n\t\tif (!this.tokenData || !this.tokenData.accessToken) {\n\t\t\tthis.adapter.log.warn('[storeToken] No access token available to store');\n\t\t\treturn;\n\t\t}\n\t\t// Store the token in the adapter's native object\n\t\tthis.adapter.extendForeignObject(`system.adapter.${this.adapter.namespace}`, {\n\t\t\tnative: {\n\t\t\t\tactiveToken: this.tokenData,\n\t\t\t\t//activeToken: tokenData,\n\t\t\t},\n\t\t});\n\t}\n\n\tasync initTokenData(): Promise<TokenData> {\n\t\t// Retrieve token Data\n\t\t//return (async () => {\n\n\t\tthis.adapter.log.debug('[initTokenData#]');\n\t\tlet tokenData = await this.getStoredTokenData();\n\n\t\tif (!tokenData) {\n\t\t\ttry {\n\t\t\t\ttokenData = await this.getTokenWithLogin();\n\t\t\t\tthis.storeToken();\n\t\t\t\t//await this.storeToken(tokenData);\n\t\t\t} catch (error) {\n\t\t\t\tthis.adapter.log.error(`[initTokenData] Login failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n\t\t\t\tthrow new Error(`Login failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n\t\t\t}\n\t\t}\n\n\t\tthis.adapter.log.debug(`initTokenData: Tokendata: ${tokenData.expiresAt}`);\n\t\tthis.tokenData = tokenData\n\t\tthis.tokenPromise = null;\n\t\treturn tokenData;\n\t\t//})();\n\t}\n\n\tasync getStoredTokenData(): Promise<TokenData | null> {\n\t\tthis.adapter.log.debug('[getStoredTokenData#]');\n\t\t// Return the stored token data if available\n\t\treturn await this.adapter.getForeignObjectAsync(`system.adapter.${this.adapter.namespace}`)\n\t\t\t.then(obj => {\n\t\t\t\tif (obj && obj.native && obj.native.activeToken) {\n\t\t\t\t\t//this.adapter.log.debug(`[getStoredTokenData] Loaded token data: ${JSON.stringify(obj.native.activeToken)}`);\n\t\t\t\t\tconst tokenData = obj.native.activeToken; // nur tempor\u00E4r\n\t\t\t\t\tthis.adapter.log.debug(`[getStoredTokenData] Loaded token data:${tokenData.accessToken.substring(0, 30)}`);\n\t\t\t\t\t//this.adapter.log.debug(`[getStoredTokenData] Loaded token data expires at: ${obj.native.activeToken.expiresAt}`);\n\t\t\t\t\t//this.adapter.log.debug(`[getStoredTokenData] Loaded token data expires at: ${this.showTimeStamp(obj.native.activeToken.expiresAt)}`);\n\t\t\t\t\treturn {\n\t\t\t\t\t\taccessToken: obj.native.activeToken.accessToken,\n\t\t\t\t\t\trefreshToken: obj.native.activeToken.refreshToken,\n\t\t\t\t\t\tuserId: obj.native.activeToken.userId,\n\t\t\t\t\t\texpiresAt: obj.native.activeToken.expiresAt,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis.adapter.log.debug('[getStoredTokenData] No token data found');\n\t\t\t\treturn null;\n\t\t\t});\n\t}\n\n\tprivate showTimeStamp(ts: number): string {\n\t\tconst date = new Date(ts);\n\t\tconst dateString = date.toISOString();\n\t\t//console.log(dateString);\n\t\treturn dateString;\n\t}\n\n\t/**\n\t * Retrieves the user ID from the token data.\n\t *\n\t * @returns {Promise<number | undefined>} The user ID if available, otherwise undefined.\n\t * @throws {Error} If the token data is not available.\n\t */\n\tasync getUserId(): Promise<number | undefined> {\n\t\tthis.adapter.log.debug('[getUserId#]');\n\t\tconst userId = (await this.tokenData)?.userId;\n\t\tif (userId === undefined) {\n\t\t\tthis.adapter.log.warn('[getUserId] No user ID available in token data');\n\t\t\tthrow new Error('User ID is not available in token data');\n\t\t}\n\t\tthis.adapter.log.debug(`[getUserId] User ID: ${userId}`);\n\t\t// Return the user ID from the token data\n\t\treturn userId;\n\t}\n}\n\n"],
  "mappings": "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",
  "names": []
}
